'use strict';

// Which files and actions to track
// Only track Add, Change, Modify to JavaScript, HTML, CSS, and YAML files
const EDIT_PAT = /^[ACM]\s+(.*[.](?:js|jsx|ts|tsx|css|html?|yml))$/;

// Ignore anything in node_modules, dist, or build
const IGNORE_PAT = /\s(?:node_modules|build|dist[/])/;

// What threshold for being an active contributor. Range: 0 to 1.
// This says 5%
const THRESHOLD = 0.05;

const count = (lst, fn) => (
  lst.reduce((n, x) => fn(x) ? n + 1 : n, 0)
);

// decay-based activity
const halfLife = 7;
const lambda = Math.log(2) / halfLife;
const day = 24 * 60 * 60 * 1000;

const days = (m, n) => Math.abs(m - n) / day;

const decay = (now, then) => Math.exp(-lambda * days(now, then));

const AUTHOR_PAT = /^Author:\s+(.+)\s+</;
const isAuthorLine = (line) => AUTHOR_PAT.test(line);
const getAuthor = (line) => AUTHOR_PAT.exec(line)[1];

const COAUTHOR_PAT = /^Co-authored-by:\s+(.+)\s+</;
const isCoAuthorLine = (line) => COAUTHOR_PAT.test(line);
const getCoAuthor = (line) => COAUTHOR_PAT.exec(line)[1];

const getName = (gitname, names) => names?.[gitname] || gitname;

const DATE_PAT = /^Date:\s+(.+)$/;
const isDateLine = (line) => DATE_PAT.test(line);
const getDate = (line) => DATE_PAT.exec(line)[1];

const isCodeFileLine = (line) => EDIT_PAT.test(line) && !IGNORE_PAT.test(line);

const getFile = (line) => EDIT_PAT.exec(line)[1];

const fileFrecency = (editHistory) => (
  Object.keys(editHistory).reduce((sum, author) => sum + editHistory[author].frecency, 0)
);

const isActiveContributor = (fileFrecency, authorEntry) => (
  authorEntry.frecency / fileFrecency >= THRESHOLD
);

const countActiveContributors = (frecency, editHistory) => {
  return count(Object.values(editHistory), entry => isActiveContributor(frecency, entry));
};

// returns short date string of the next Sunday after a timestamp,
// -- if timestamp is on a Sunday, the next Sunday is returned
const getNextSunday = (ts) => {
  const date = new Date(ts);
  date.setDate(date.getDate() - date.getDay() + 7);
  return new Date(date).toLocaleDateString();
};

// returns how many timestamps occurred in the week before a given Sunday 
export const countCommits = (timestamps, sunday) => (
  count(timestamps, ts => sunday === getNextSunday(ts))
);

// return aggregate data for file activity
//  - total edits, last edit, total frecency, number of serious contributors
const makeFileEntry = (file, editHistory) => {
  const frecency = fileFrecency(editHistory);
  const actives = countActiveContributors(frecency, editHistory);
  return { file, frecency, actives, authors: editHistory };
};

// Create a commit object with each author line.
// Assumes author line comes first in git log output.
const newCommit = (author) => ({ authors: [author], files: [] });

const getCommits = (text, names) => {
  const lines = text.split(/\n|\r/);
  const commits = [];
  let commit = null;
  lines.forEach(line => {
    if (isAuthorLine(line)) {
      commit = newCommit(getName(getAuthor(line), names));
      commits.push(commit);
    } else if (isDateLine(line)) {
      commit.date = Date.parse(getDate(line));
    } else if (isCodeFileLine(line)) {
      commit.files.push(getFile(line));
    } else if (isCoAuthorLine(line)) {
      commit.authors.push(getName(getCoAuthor(line), names));
    }
  })
  return commits;
};

const getAllAuthors = (commits) => (
  Array.from(new Set(commits.flatMap(commit => commit.authors))).sort()
);

const getAllFiles = (commits) => (
  Array.from(new Set(commits.flatMap(commit => commit.files)))
);

const getAllWeeks = (commits) => (
  Array.from(new Set(commits.map(commit => getNextSunday(commit.date))))
);

// counts how often author1 worked with author2
// -- if author1 = author2, counts how often author1 worked alone
const countPairs = (author1, author2, commits) => (
  author1 === author2
    ? count(commits, commit => commit.authors.includes(author1) && commit.authors.length === 1)
    : commits.reduce((sum, commit) => (
        commit.authors.includes(author1) && commit.authors.includes(author2)
          ? sum + 1
          : sum
      ), 0)
  );

const getData = (text, names) => {
  // step through log generated by git log --no-merges --name-status

  const allCommits = getCommits(text, names);
  const latestCommitTime = allCommits[0].date;

  const authors = getAllAuthors(allCommits)

  // create a list of commit times for each author
  const commits = Object.fromEntries(authors.map(author => [
    author,
    allCommits.filter(commit => commit.authors.includes(author))
    .map(commit => commit.date)
  ]));

  // calculate number of ollaborations on commits for every pair of authors
  const collaborations = Object.fromEntries(authors.map((author1, i) => ([
    author1,
    Object.fromEntries(authors.slice(i).map(author2 => ([
      author2,
      countPairs(author1, author2, allCommits)
    ])))
  ])));

  const hasCollaborations = (
    Object.values(collaborations).some(collabs => Object.values(collabs).slice(1).some(count => count > 0))
  );

  // calculate the edit history for each file, which is a list of edits for each author with a frecency score
  // -- works from newest to oldest commits
  // -- edit value decays relative to latest edit in the repo
  const editHistory = Object.fromEntries(getAllFiles(allCommits).map(file => (
    [
      file,
      Object.fromEntries(authors.map(author => [author, { edits: [], frecency: 0 }]))
    ]
  )));

  allCommits.forEach(commit => {
    const decayedValue = decay(latestCommitTime, commit.date);
    commit.files.forEach(file => {
      commit.authors.forEach(author => {
        editHistory[file][author].frecency += decayedValue;
        editHistory[file][author].edits.push(commit.date);
      });
    });
  });

  // create a list of entries organized by file with aggregate data
  const files =  Object.keys(editHistory)
    .map(file => makeFileEntry(file, editHistory[file]))
    .sort((entry1, entry2) => entry2.frecency - entry1.frecency);


  return { 
    files, 
    authors, 
    commits, 
    weeks: getAllWeeks(allCommits), 
    collaborations: hasCollaborations ? collaborations : null };
};

const loadFile = (file, callback) => {
  const reader = new FileReader();

  reader.addEventListener("load", () => {
    callback(reader.result);
  }, false);

  if (file) {
    reader.readAsText(file);
  }
};

export { getData, isActiveContributor, loadFile };